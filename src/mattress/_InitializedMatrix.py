from typing import Tuple, Sequence, Optional

import numpy
import delayedarray

from . import _lib_mattress as lib
from ._utils import _sanitize_subset

__author__ = "ltla, jkanche"
__copyright__ = "ltla, jkanche"
__license__ = "MIT"


def _factorize(group):
    mapping = {}
    indices = numpy.ndarray((len(group),), numpy.uint32)
    levels = []
    for i, x in enumerate(group):
        if x not in mapping:
            mapping[x] = len(levels)
            levels.append(x)
        indices[i] = mapping[x]
    return levels, indices


class InitializedMatrix:
    """
    Pointer to an object containing a ``tatami::Matrix``, typically generated by :py:func:`~initialize.initialize` for use in C++ code.
    Instances of this class should only be created by developers and used within package functions;
    this is done by passing the :py:attr:`~ptr` address to C++ and casting it to a pointer to a ``mattress::BoundMatrix`` (see the ``mattress.h`` header).
    All ``InitializedMatrix`` instances are expected to be transient within a Python session; they should not be serialized, nor should they be visible to end users.
    Each instance will automatically free the C++-allocated memory upon garbage collection.
    """

    def __init__(self, ptr: int):
        """
        This constructor should only be called by registered methods for :py:func:`~mattress.initialize.initialize`.

        Args:
            ptr:
                Address of a ``mattress::BoundMatrix`` instance.
                This is typically obtained by passing a ``std::uintptr_t`` from C++ code.
        """
        self._ptr = ptr

    def __del__(self):
        """
        Free the C++ object at :py:attr:`~ptr`.
        """
        lib.free_mattress(self._ptr)

    def nrow(self) -> int:
        """
        Get the number of rows in the matrix.

        Returns:
            Number of rows.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.nrow()
        """
        return self.shape[0];

    def ncol(self) -> int:
        """
        Get the number of columns in the matrix.

        Returns:
            Number of columns.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.ncol()
        """
        return self.shape[1];

    @property
    def shape(self) -> Tuple[int, int]:
        """
        Shape of the matrix, to masquerade as a NumPy-like object.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.shape
        """
        return lib.get_dim(self._ptr)

    @property
    def ptr(self) -> int:
        """
        Address to a ``mattress::BoundMatrix`` instance, to be passed as a ``std::uintptr_t`` to C++ - see the ``mattress.h`` header.
        This should not be used after the ``InitializedMatrix`` is deleted.
        This should not be used to construct a new ``InitializedMatrix``.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.ptr
        """
        return self._ptr

    @property
    def dtype(self) -> numpy.dtype:
        """
        Type of the matrix, to masquerade as a NumPy-like object.
        This is always a double-precision type.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.dtype
        """
        return numpy.dtype("float64")

    def __array__(self, dtype: Optional[numpy.dtype] = None, copy: Optional[bool] = None) -> numpy.ndarray:
        """
        Realize the underlying matrix into a dense NumPy array.

        Args:
            dtype:
                Type of the output matrix.
                If ``None``, defaults to a double-precision type.

            copy:
                Ignored, a copy is always made.

        Returns:
            Contents of the underlying matrix, cast to the specified ``dtype``.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.__array__()
        """
        shape = self.shape;
        out = _extract_array(self, (range(shape[0]), range(shape[1])), sparse=False)
        if dtype is not None and dtype != self.dtype:
            out = out.astype(dtype)
        return out

    def __DelayedArray_dask__(self) -> numpy.ndarray:
        """
        Enable the use of the poiners with dask.

        See :py:meth:`~delayedarray.DelayedArray.DelayedArray.__DelayedArray_dask__` for details.

        This is largely a placeholder method for compatibility;
        it just realizes the underlying matrix into a dense array under the hood.

        Returns:
            Contents of the underlying matrix.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.__DelayedArray_dask__()
        """
        return self.__array__()

    def sparse(self) -> bool:
        """
        Is the matrix sparse?

        Returns:
            True if matrix is sparse.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.sparse()
        """
        return lib.get_sparse(self._ptr);

    def row(self, r: int) -> numpy.ndarray:
        """
        Access a row from the tatami matrix.
        This method is primarily intended for troubleshooting and should not be used to iterate over the matrix in production code.
        (Do that in C++ instead.)

        Args:
            r:
                Row to access.
                This should be non-negative and less than :py:meth:`~nrow`.

        Returns:
            Contents of row ``r`` of the matrix.
            This is always in double-precision, regardless of the underlying representation.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(1000, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row(0)
        """
        return lib.extract_row(self._ptr, r)

    def column(self, c: int) -> numpy.ndarray:
        """
        Access a column from the tatami matrix.
        This method is primarily intended for troubleshooting and should not be used to iterate over the matrix in production code.
        (Do that in C++ instead.)

        Args:
            c:
                Column to access.
                This should be non-negative and less than :py:meth:`~ncol`.

        Returns:
            Contents of column ``c`` from the matrix.
            This is always in double-precision, regardless of the underlying representation.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column(0)
        """
        return lib.extract_column(self._ptr, c)

    def row_sums(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute row sums.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of row sums.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_sums()
        """
        return lib.compute_row_sums(self._ptr, num_threads)

    def column_sums(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute column sums.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of column sums.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_sums()
        """
        return lib.compute_column_sums(self._ptr, num_threads)

    def row_variances(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute row variances.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of row variances.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_variances()
        """
        return lib.compute_row_variances(self._ptr, num_threads)

    def column_variances(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute column variances.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of column variances.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_variances()
        """
        return lib.compute_column_variances(self._ptr, num_threads)

    def row_medians(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute row medians.

        Args:
            num_threads: Number of threads.

        Returns:
            Double-precision array of row medians.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_medians()
        """
        return lib.compute_row_medians(self._ptr, num_threads)

    def column_medians(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute column medians.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of column medians.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_medians()
        """
        return lib.compute_column_medians(self._ptr, num_threads)

    def row_mins(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute row minima.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of row minima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_mins()
        """
        return lib.compute_row_mins(self._ptr, num_threads)

    def column_mins(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute column minima.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of column minima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_mins()
        """
        return lib.compute_column_mins(self._ptr, num_threads)

    def row_maxs(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute row maxima.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of row maxima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_maxs()
        """
        return lib.compute_row_maxs(self._ptr, num_threads)

    def column_maxs(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to compute column maxima.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Double-precision array of column maxima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_maxs()
        """
        return lib.compute_column_maxs(self._ptr, num_threads)

    def row_ranges(self, num_threads: int = 1) -> Tuple[numpy.ndarray, numpy.ndarray]:
        """
        Convenience method to compute row ranges.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Tuple of two double-precision arrays.
            The first contains the row minima and the second contains the row maxima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_ranges()
        """
        return lib.compute_row_ranges(self._ptr, num_threads)

    def column_ranges(self, num_threads: int = 1) -> Tuple[numpy.ndarray, numpy.ndarray]:
        """
        Convenience method to compute column ranges.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Tuple of two double-precision arrays.
            The first contains the column minima and the second contains the column maxima.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_ranges()
        """
        return lib.compute_column_ranges(self._ptr, num_threads)

    def row_nan_counts(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to count the number of NaNs on each row.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Integer array containing the number of NaNs in each row.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> mat[0,0] = numpy.nan
            >>> mat[9,19] = numpy.nan
            >>> ptr = mattress.initialize(mat)
            >>> ptr.row_nan_counts()
        """
        return lib.compute_row_nan_counts(self._ptr, num_threads)

    def column_nan_counts(self, num_threads: int = 1) -> numpy.ndarray:
        """
        Convenience method to count the number of NaNs on each column.

        Args:
            num_threads:
                Number of threads.

        Returns:
            Integer array containing the number of NaNs in each column.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> mat[0,0] = numpy.nan
            >>> mat[9,19] = numpy.nan
            >>> ptr = mattress.initialize(mat)
            >>> ptr.column_nan_counts()
        """
        return lib.compute_column_nan_counts(self._ptr, num_threads)

    def row_medians_by_group(
        self, group: Sequence,
        num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the row-wise median for each group of columns.

        Args:
            group:
                Sequence of length equal to the number of columns of the matrix, containing the group assignment for each column.

            num_threads:
                Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each column represents a group and contains the row-wise medians for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each column.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 10
            >>> ptr.row_medians_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.ncol():
            raise ValueError(
                "'group' should have length equal to the number of columns"
            )

        output = lib.compute_row_medians_by_group(self._ptr, ind, num_threads);
        return output, lev

    def column_medians_by_group(
        self, group: Sequence, num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the column-wise median for each group of row.

        Args:
            group:
                Sequence of length equal to the number of row of the matrix, containing the group assignment for each row.

            num_threads:
                Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each row represents a group and contains the column-wise medians for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each row.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 5
            >>> ptr.column_medians_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.nrow():
            raise ValueError("'group' should have length equal to the number of rows")

        output = lib.compute_column_medians_by_group(self._ptr, ind, num_threads)
        return output.T, lev

    def row_sums_by_group(
        self, group: Sequence, num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the row-wise sum for each group of columns.

        Args:
            group:
                Sequence of length equal to the number of columns of the matrix, containing the group assignment for each column.

            num_threads: Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each column represents a group and contains the row-wise sums for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each column.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 10
            >>> ptr.row_sums_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.ncol():
            raise ValueError(
                "'group' should have length equal to the number of columns"
            )

        output = lib.compute_row_sums_by_group(self._ptr, ind, num_threads)
        return output, lev

    def column_sums_by_group(
        self, group: Sequence, num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the column-wise sum for each group of row.

        Args:
            group:
                Sequence of length equal to the number of row of the matrix, containing the group assignment for each row.

            num_threads:
                Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each row represents a group and contains the column-wise sums for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each row.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 5
            >>> ptr.column_sums_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.nrow():
            raise ValueError("'group' should have length equal to the number of rows")

        output = lib.compute_column_sums_by_group(self._ptr, ind, num_threads)
        return output.T, lev

    def row_variances_by_group(
        self, group: Sequence, num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the row-wise variance for each group of columns.

        Args:
            group: Sequence of length equal to the number of columns of the matrix,
                containing the group assignment for each column.

            num_threads: Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each column represents a group and contains the row-wise variances for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each column.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 10
            >>> ptr.row_variances_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.ncol():
            raise ValueError(
                "'group' should have length equal to the number of columns"
            )

        output = lib.compute_row_variances_by_group(self._ptr, ind, num_threads)
        return output, lev

    def column_variances_by_group(
        self, group: Sequence, num_threads: int = 1
    ) -> Tuple[numpy.ndarray, list]:
        """
        Convenience method to compute the column-wise variance for each group of row.

        Args:
            group:
                Sequence of length equal to the number of row of the matrix, containing the group assignment for each row.

            num_threads:
                Number of threads.

        Returns:
            Tuple of (i) a 2-dimensional array where each row represents a group and contains the column-wise variances for that group;
            and (ii) a list containing the unique levels of ``group`` represented by each row.

        Examples:
            >>> import numpy
            >>> import mattress
            >>> mat = numpy.random.rand(10, 20)
            >>> ptr = mattress.initialize(mat)
            >>> group = ["A", "B"] * 5
            >>> ptr.column_variances_by_group(group)
        """
        lev, ind = _factorize(group)
        if len(ind) != self.nrow():
            raise ValueError("'group' should have length equal to the number of rows")

        output = lib.compute_column_variances_by_group(self._ptr, ind, num_threads)
        return output.T, lev


@delayedarray.is_sparse.register
def is_sparse(x: InitializedMatrix) -> bool:
    """
    See :py:func:`~delayedarray.is_sparse.is_sparse`.

    Args:
        x:
            An ``InitializedMatrix`` object.

    Returns:
        Whether ``x`` is a sparse matrix.

    Examples:
        >>> import numpy
        >>> import mattress
        >>> mat = numpy.random.rand(10, 20)
        >>> ptr = mattress.initialize(mat)
        >>> import delayedarray
        >>> delayedarray.is_sparse(ptr)
    """
    return x.sparse()


def _extract_array(x: InitializedMatrix, subset: Tuple[Sequence[int], ...], sparse: bool): 
    shape = x.shape
    rnoop, rsub = _sanitize_subset(subset[0], shape[0])
    cnoop, csub = _sanitize_subset(subset[1], shape[1])
    if not sparse:
        return lib.extract_dense_subset(x.ptr, rnoop, rsub, cnoop, csub)
    else:
        return lib.extract_sparse_subset(x.ptr, rnoop, rsub, cnoop, csub)


@delayedarray.extract_dense_array.register
def extract_dense_array(x: InitializedMatrix, subset: Tuple[Sequence[int], ...]) -> numpy.ndarray:
    """
    See :py:func:`~delayedarray.extract_dense_array.extract_dense_array`.

    Args:
        x: 
            An ``InitializedMatrix`` object.

        subset:
            Tuple of sorted and unique integer sequences indicating the rows/columns to extract.

    Returns:
        Contents of the submatrix.

    Examples:
        >>> import numpy
        >>> import mattress
        >>> mat = numpy.random.rand(10, 20)
        >>> ptr = mattress.initialize(mat)
        >>> import delayedarray
        >>> delayedarray.extract_dense_array(ptr, (range(5), range(5)))
    """
    return _extract_array(x, subset, False)


@delayedarray.extract_sparse_array.register
def extract_sparse_array(x: InitializedMatrix, subset: Tuple[Sequence[int], ...]) -> delayedarray.SparseNdarray:
    """
    See :py:func:`~delayedarray.extract_sparse_array.extract_sparse_array`.

    Args:
        x: 
            An ``InitializedMatrix`` object.

        subset:
            Tuple of sorted and unique integer sequences indicating the rows/columns to extract.

    Returns:
        Contents of the submatrix as a sparse array.

    Examples:
        >>> import scipy 
        >>> import mattress
        >>> mat = scipy.sparse.random_array((10, 20), density=0.2).tocsc()
        >>> ptr = mattress.initialize(mat)
        >>> import delayedarray
        >>> delayedarray.extract_sparse_array(ptr, (range(5), range(5)))
    """
    return _extract_array(x, subset, True)

@delayedarray.is_masked.register
def is_masked(x: InitializedMatrix) -> bool:
    """
    See :py:func:`~delayedarray.is_masked.is_masked`.

    Args:
        x: 
            An ``InitializedMatrix`` object.

    Returns:
        Whether the matrix is masked. 
        (It's not.)

    Examples:
        >>> import scipy 
        >>> import mattress
        >>> mat = scipy.sparse.random_array((10, 20), density=0.2).tocsc()
        >>> ptr = mattress.initialize(mat)
        >>> import delayedarray
        >>> delayedarray.is_masked(ptr)
    """
    return False

@delayedarray.chunk_grid.register
def chunk_grid(x: InitializedMatrix) -> bool:
    """
    See :py:func:`~delayedarray.chunk_grid.chunk_grid`.

    Args:
        x: 
            An ``InitializedMatrix`` object.

    Returns:
        An obligatory grid describing how to iterate over the matrix.

    Examples:
        >>> import scipy 
        >>> import mattress
        >>> mat = scipy.sparse.random_array((10, 20), density=0.2).tocsc()
        >>> ptr = mattress.initialize(mat)
        >>> import delayedarray
        >>> delayedarray.chunk_grid(ptr)
    """
    return delayedarray.chunk_shape_to_grid((1, 1), x.shape, cost_factor=1)
